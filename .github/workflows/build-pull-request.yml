# Name of the workflow
name: Build Pull Request

# Trigger the workflow on pull requests
on:
  pull_request:
    # Only run the workflow when non-Markdown files are changed
    paths:
      - '**'

jobs:

  build:
    # Run the job on the latest Ubuntu runner
    runs-on: ubuntu-latest

    # Define a matrix strategy to run the job for multiple languages
    strategy:
      matrix:
        language: ['csharp', 'go', 'python', 'java', 'typescript']

    steps:
      # Checkout the code from the repository
      - name: Checkout code
        uses: actions/checkout@v4

      # Set up the required environment for the specified language
      - name: Setup Language
        uses: ./.github/actions/setup-language
        with:
          language: ${{ matrix.language }}

      # Get the list of changed files, excluding Markdown files and deleted files
      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@27ae6b33eaed7bf87272fdeb9f1c54f9facc9d99
        with:
          files: ${{ matrix.language }}/**
          files_ignore: '**/*.md'
          files_separator: ' '

      # Build the changed files for the specified language
      - name: Build changed files
        if: steps.changed-files.outputs.any_changed == 'true'
        run: |
          # Create a temporary directory for build logs
          mkdir -p /tmp/build_logs
          npm install -g eslint

          # Function to build a single file
          build_file() {
            echo "Build File $1"
            local file="$1"
            local log_file="/tmp/build_logs/$(basename "$file" | sed 's/\//_/g').log"
            IFS="/" read -ra path_parts <<< "$file"
            language=${path_parts[0]}

            # Skip files that don't belong to the current language
            if [[ $language != ${{ matrix.language }} ]]; then
              return 0
            fi

            echo "Build Path $file"

            # Run the build script for the current language, passing the project directory and extra path
            echo "::group::$file"
            if ../scripts/build-${language}.sh "$file" > "$log_file" 2>&1; then
              echo "::endgroup::"
              return 0
            else
              local exit_code=$?
              echo "::endgroup::"
              echo "::group::Error details for $file"
              cat "$log_file"
              echo "::endgroup::"
              echo "::error::Build failed for $file with exit code $exit_code"
              return $exit_code
            fi
          }

          # Export the build_file function for use in parallel
          export -f build_file

          # Create an array to store directories to be built
          apps_to_build=()

          # Use only added and modified files, ignoring deleted files
          files=(${{ steps.changed-files.outputs.added_files }} ${{ steps.changed-files.outputs.modified_files }})

          # Check the directories of each changed file for cdk.json
          for file in "${files[@]}"; do
            IFS="/" read -ra path_parts <<< "$file"
            language=${path_parts[0]}
            dir="${path_parts[0]}/${path_parts[1]}"

            # Skip files that don't belong to the current language
            if [[ $language != ${{ matrix.language }} ]]; then
              continue
            fi

            apps_to_build+=("$(find "$dir" -name 'cdk.json')")
          done

          # Remove duplicate projects
          apps_to_build=($(printf "%s\n" "${apps_to_build[@]}" | sort -u))

          # Print the projects to be built
          echo "projects to build:"
          for dir in "${apps_to_build[@]}"; do
            echo "- $dir"
          done

          # Change to language directory
          cd ./${{ matrix.language }}

          # install CDK CLI from npm if not typescript, so that npx can find it later
          # ts will use the one from the particular cdk app
          if [[ ${{ matrix.language }} != 'typescript' ]]; then
            npm install -g aws-cdk
            npx cdk --version
          fi

          # Run the build_file function in parallel for each project to be built
          # Halt the execution if any of the build_file invocations fail
          parallel --keep-order --halt-on-error 2 build_file ::: "${apps_to_build[@]}"

          # Check the exit status of parallel
          parallel_exit=$?

          # If parallel succeeded, clean up node_modules and cdk.out to save space
          if [ $parallel_exit -eq 0 ]; then
            echo "::group::Cleaning up build artifacts"
            # Find all node_modules directories within the language directory and remove them
            echo "Removing node_modules directories..."
            find ./ -name "node_modules" -type d -prune -exec rm -rf {} \; 2>/dev/null || true

            # Find all cdk.out directories within the language directory and remove them
            echo "Removing cdk.out directories..."
            find ./ -name "cdk.out" -type d -prune -exec rm -rf {} \; 2>/dev/null || true

            echo "Cleanup completed"
            echo "::endgroup::"
          fi

          # If parallel failed, make sure the workflow fails too
          if [ $parallel_exit -ne 0 ]; then
            echo "::error::One or more builds failed. See error details above."
            exit $parallel_exit
          fi
